import { Pack, Puzzle, PackSummary } from '@/domain/puzzle';
import { PackSchema, PackSummarySchema } from '@/lib/schemas/pack';
import { PuzzleSchema } from '@/lib/schemas/puzzle';

/**
 * Load and validate a pack metadata file.
 */
export async function loadPack(packId: string): Promise<Pack> {
  const response = await fetch(`/packs/${packId}/metadata.json`);
  if (!response.ok) {
    throw new Error(`Failed to load pack ${packId}: ${response.statusText}`);
  }
  const data = await response.json();
  return PackSchema.parse(data) as Pack;
}

/**
 * Load and validate a specific puzzle from a pack.
 */
export async function loadPuzzle(packId: string, puzzleId: string): Promise<Puzzle> {
  const response = await fetch(`/packs/${packId}/puzzles/${puzzleId}.json`);
  if (!response.ok) {
    throw new Error(`Failed to load puzzle ${puzzleId} from pack ${packId}: ${response.statusText}`);
  }
  const data = await response.json();
  return PuzzleSchema.parse(data) as Puzzle;
}

/**
 * Load all available packs (summary list).
 * In MVP, this reads a static index file or discovers pack directories.
 */
export async function loadPacksList(): Promise<PackSummary[]> {
  // MVP: Assume a static packs-index.json exists
  // Generated by CLI or manually curated
  const response = await fetch('/packs/index.json');
  if (!response.ok) {
    // Fallback to empty if index doesn't exist yet
    console.warn('Packs index not found, returning empty list');
    return [];
  }
  const data = await response.json();
  if (!Array.isArray(data)) {
    throw new Error('Packs index must be an array');
  }
  return data.map((item) => PackSummarySchema.parse(item)) as PackSummary[];
}

/**
 * Load all puzzles for a pack (metadata only, not full puzzle data).
 */
export async function loadPackPuzzles(packId: string): Promise<string[]> {
  const pack = await loadPack(packId);
  return pack.puzzles;
}
