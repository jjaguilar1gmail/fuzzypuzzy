import { Pack, Puzzle, PackSummary } from '@/domain/puzzle';
import { PackSchema, PackSummarySchema } from '@/lib/schemas/pack';
import { PuzzleSchema } from '@/lib/schemas/puzzle';

// In-memory cache for loaded data
const packsListCache: { data: PackSummary[] | null; promise: Promise<PackSummary[]> | null } = {
  data: null,
  promise: null,
};

const packMetadataCache = new Map<string, Pack>();
const puzzleCache = new Map<string, Puzzle>();

/**
 * Load and validate a pack metadata file.
 */
export async function loadPack(packId: string): Promise<Pack> {
  // Check cache first
  if (packMetadataCache.has(packId)) {
    return packMetadataCache.get(packId)!;
  }

  const response = await fetch(`/packs/${packId}/metadata.json`);
  if (!response.ok) {
    throw new Error(`Failed to load pack ${packId}: ${response.statusText}`);
  }
  const data = await response.json();
  const pack = PackSchema.parse(data) as Pack;
  
  // Store in cache
  packMetadataCache.set(packId, pack);
  
  return pack;
}

/**
 * Load and validate a specific puzzle from a pack.
 */
export async function loadPuzzle(packId: string, puzzleId: string): Promise<Puzzle> {
  // Check cache first
  const cacheKey = `${packId}/${puzzleId}`;
  if (puzzleCache.has(cacheKey)) {
    return puzzleCache.get(cacheKey)!;
  }

  const response = await fetch(`/packs/${packId}/puzzles/${puzzleId}.json`);
  if (!response.ok) {
    throw new Error(`Failed to load puzzle ${puzzleId} from pack ${packId}: ${response.statusText}`);
  }
  const data = await response.json();
  const puzzle = PuzzleSchema.parse(data) as Puzzle;
  
  // Store in cache
  puzzleCache.set(cacheKey, puzzle);
  
  return puzzle;
}

/**
 * Load all available packs (summary list).
 * In MVP, this reads a static index file or discovers pack directories.
 */
export async function loadPacksList(): Promise<PackSummary[]> {
  // Return cached data if available
  if (packsListCache.data) {
    return packsListCache.data;
  }

  // Return existing promise if loading is in progress
  if (packsListCache.promise) {
    return packsListCache.promise;
  }

  // Start loading
  packsListCache.promise = (async () => {
    // MVP: Assume a static packs-index.json exists
    // Generated by CLI or manually curated
    const response = await fetch('/packs/index.json');
    if (!response.ok) {
      // Fallback to empty if index doesn't exist yet
      console.warn('Packs index not found, returning empty list');
      return [];
    }
    const data = await response.json();
    if (!Array.isArray(data)) {
      throw new Error('Packs index must be an array');
    }
    const packs = data.map((item) => PackSummarySchema.parse(item)) as PackSummary[];
    
    // Store in cache
    packsListCache.data = packs;
    packsListCache.promise = null;
    
    return packs;
  })();

  return packsListCache.promise;
}

/**
 * Load all puzzles for a pack (metadata only, not full puzzle data).
 */
export async function loadPackPuzzles(packId: string): Promise<string[]> {
  const pack = await loadPack(packId);
  return pack.puzzles;
}
